#!/bin/bash

###############################################################################
#
#   Script developped in 2019 by
#   CFD FEA SERVICE SRL - via Borgo Grande 19, 37044 Cologna Veneta VR
#
#   License: GPLv3
#
###############################################################################

cp -r system/.snappyHexMeshDict.org         system/snappyHexMeshDict
cp -r system/.surfaceFeaturesDict.org       system/surfaceFeaturesDict
cp -r system/.surfaceFeatureExtractDict.org system/surfaceFeatureExtractDict
cp -r system/.blockMeshDict.org             system/blockMeshDict
cp -r system/.createPatchDict               system/createPatchDict
cp -r system/.meshDict 		            system/meshDict

############################################

echo "Renaming SolidWorks STL files ..."

rename 's/STL/stl/' constant/triSurface/*
chmod ugo+rw constant/*/*stl

############################################

echo "Getting BC list ..."

rm constant/triSurface/*.eMesh
surf_files=$( ls constant/surfSurface/*.stl | xargs -n1 basename )

for file in $surf_files
do
  BCname=${file%.stl}
  echo "   New bc found: $BCname"

  #All files are copied into triSurface
  cp constant/surfSurface/$file constant/triSurface/.
done

echo "Convertin STL to binaries ..."

rm -rf tmp_stl
mkdir tmp_stl
stl_list=""

#Conversione in STL binari
for file in $surf_files
do
  stl_convert  constant/surfSurface/$file tmp_stl/$file
  stl_list="$stl_list tmp_stl/$file"
done

#Unione di tutti gli STL surface in un unico file
coarseMesh=$( xmllint  --xpath "string(//INPUTDATA/MESH/coarseMesh)" CFD_input.xml )
stl_merge -o stl-completo.stl $stl_list
mapfile -t replace_string < <(stl_bbox stl-completo.stl $coarseMesh)

echo "${replace_string[1]}"

sed -i "s/SCRIPT-GRID/${replace_string[0]}/g" system/blockMeshDict
sed -i "s/SCRIPT-BBOX/${replace_string[2]}/g" system/blockMeshDict

#Controllo se l'unione dei SURFSTL e' chiuso o meno
nborders=$(stl_borders stl-completo.stl)

if [ ! "$nborders" = "0" ]
then
   echo "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"
   echo "@@@@ FILE STL APERTO @@@ WARNING !!! @@@@"
   echo "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"
   echo " -> Nborders $nborders"
   echo " -> visionare file stl-completo.stl"
else
   rm -rf stl-completo.stl
fi

rm -rf tmp_stl

############################################

echo "Getting POINT file ..."

#Trova il punto prima come file vtk che ha la precedenza, poi nel file XML
point_files=$( ls constant/point/*.vtk | xargs -n1 basename )

if [ "${point_files[0]}" = "" ]
then
	#punto interno al volume fluido
	xPto=$( xmllint  --xpath "string(//INPUTDATA/MESH/pointInside/x)" CFD_input.xml )
	yPto=$( xmllint  --xpath "string(//INPUTDATA/MESH/pointInside/y)" CFD_input.xml )
	zPto=$( xmllint  --xpath "string(//INPUTDATA/MESH/pointInside/z)" CFD_input.xml )

	replace_string="\tlocationInMesh   ( $xPto $yPto $zPto );"
	sed -i "s/SCRIPT-POINT-INSIDE/$replace_string/g" system/snappyHexMeshDict

else
   for file in $point_files
   do
      point=$(fgrep . constant/point/$file | grep -v "#" | sed 's/\r$//g')
      echo "   New POINT found: $file ( $point )"

      sed -i "s/SCRIPT-POINT-INSIDE/\tlocationInMesh ( $point );/g" system/snappyHexMeshDict
   done

fi

############################################
#se nel file input data almeno una superficie inserita ha un numero di layers non nullo allora attiva l'opzione layers
replace_string="false"

for file in $surf_files
do
	BCname=${file%.stl}

        #Verifica esistenza file STL nel file XML
        if [ $(xmllint  --xpath "count(//INPUTDATA/MESH/$BCname)" CFD_input.xml) -eq 0 ]
        then
           echo " @@@@@@@   MISSING BOUNDARY DEFINITION in XML file - $BCname"
        fi

	numOfLayers=$( xmllint  --xpath "string(//INPUTDATA/MESH/$BCname/numOfLayers)" CFD_input.xml )
	if [ ! "$numOfLayers" = "" ];
	then
		if [ ! "$numOfLayers" = "0" ];
		then
			replace_string="true"
		else
			replace_string="$replace_string"
		fi
	else
		if [ ! "$numOfLayers" = "0" ];
		then
			replace_string="true"
		else
			replace_string="$replace_string"
		fi
	fi
done

sed -i "s/layersTrueOrFalse/$replace_string/g" system/snappyHexMeshDict

############################################
#cerco se ci sono delle symmetry, se ci sono aggiungo una parte di codice in createPatchDict
replace_string=""

for file in $surf_files
do
  BCname=${file%.stl}
	
	if [ "$BCname" = "symmetry" ];
	then
		replace_string="\n\t{\n\t\tname\tsymmetry-tmp;\n\t\tconstructFrom\tpatches;\n\t\tpatches\t( symmetry );\n\t\tpatchInfo\n\t\t{\n\t\t\ttype\tsymmetry;\n\t\t}\n\t}\n"
	else
		replace_string="$replace_string"
	fi
done

sed -i "s/SCRIPT-SYMMETRY/$replace_string/g" system/createPatchDict

############################################

echo "Getting INTSURF list ..."

int_files=$( ls constant/internSurface/*.stl | xargs -n1 basename )

for file in $int_files
do
  INTname=${file%.stl}
  echo "   New INT found: $INTname"

  #All files are copied into triSurface
  cp constant/internSurface/$file constant/triSurface/.
done

############################################

echo "Getting VOL list ..."

vol_files=$( ls constant/volSurface/*.stl | xargs -n1 basename )

for file in $vol_files
do
  VOLname=${file%.stl}
  echo "   New VOL found: $VOLname"

  #All files are copied into triSurface
  cp constant/volSurface/$file constant/triSurface/.
done

############################################

echo "Getting BAFFLE list ..."

baf_files=$( ls constant/baffleSurface/*.stl | xargs -n1 basename )

for file in $baf_files
do
  BAFname=${file%.stl}
  echo "   New BAF found: $BAFname"

  #All files are copied into triSurface
  cp constant/baffleSurface/$file constant/triSurface/.
done

############################################

echo ""
echo "Layers controls ..."

replace_string=""

for file in $surf_files
do
   BCname=${file%.stl}

   #numero di layers per ogni surf (se lo trova gli assegna il valore trovato, altrimenti mette 0)
   numOfLayers=$( xmllint  --xpath "string(//INPUTDATA/MESH/$BCname/numOfLayers)" CFD_input.xml )

   if [ "$numOfLayers" = "" -o "$numOfLayers" = "0" ]; then
      continue
   fi   

   echo "   Layers: $BCname - $numOfLayers"

   replace_string="$replace_string\t\t$BCname\n\t\t{\n\t\t\tnSurfaceLayers\t$numOfLayers;\n\t\t}\n"
done

sed -i "s/SCRIPT-LAYERS/$replace_string/g" system/snappyHexMeshDict

############################################

echo ""
echo "Features ..."

replace_string=""

for file in $surf_files
do
	BCname=${file%.stl}

	#se c'è refinement angoli altrimenti se c'è refinementmax altrimenti 1
	refMax=$( xmllint  --xpath "string(//INPUTDATA/MESH/$BCname/refMax)" CFD_input.xml )
	refOnCorners=$( xmllint  --xpath "string(//INPUTDATA/MESH/$BCname/refOnCorners)" CFD_input.xml )

	if [ "$refOnCorners" = "" ]; then
	   if [ "$refMax" = "" ]; then
		refOnCorners=1
     	   else
	   	refOnCorners=$refMax
   	   fi
	fi
	 
   	echo "   CornerRef: $BCname - $refOnCorners"

	replace_string="$replace_string\t\t{\n\t\t\tfile\t\"$BCname.extendedFeatureEdgeMesh\";\n\t\t\tlevel\t$refOnCorners;\n\t\t}\n"
	#replace_string="$replace_string\t\t{\n\t\t\tfile\t\"$BCname.eMesh\";\n\t\t\tlevel\t$refOnCorners;\n\t\t}\n"
done

sed -i "s/SCRIPT-FEATURES/$replace_string/g" system/snappyHexMeshDict

############################################

echo ""
echo "Refinemet regions ..."

replace_string=""

for file in $vol_files
do
  VOLname=${file%.stl}

        #Verifica esistenza file STL nel file XML
        if [ $(xmllint  --xpath "count(//INPUTDATA/MESH/$VOLname)" CFD_input.xml) -eq 0 ]
        then
           echo " @@@@@@@   MISSING VOLUME DEFINITION in XML file - $VOLname"
        fi
  
	#se c'è refinement refinementmax altrimenti 0
	refMax=$( xmllint  --xpath "string(//INPUTDATA/MESH/$VOLname/refMax)" CFD_input.xml )

	if [ "$refMax" = "" ]; then
		refMax=0
	fi
	
   	echo "   VolumeRef: $VOLname - $refMax"

	replace_string="$replace_string\t\t$VOLname\n\t\t{\n\t\t\tmode\tinside;\n\t\t\tlevels\t(( 1.0  $refMax));\n\t\t}\n"
done

sed -i "s/SCRIPT-REGREF/$replace_string/g" system/snappyHexMeshDict

############################################

echo ""
echo "Refinemet surface ..."

replace_string=""

for file in $surf_files
do
  BCname=${file%.stl}
  
	#se c'è refinementmin refinementmax, altrimenti refinementmax refinementmax , altrimenti 0 0
	refMax=$( xmllint  --xpath "string(//INPUTDATA/MESH/$BCname/refMax)" CFD_input.xml )
	refMin=$( xmllint  --xpath "string(//INPUTDATA/MESH/$BCname/refMin)" CFD_input.xml )
	
	#di che tipologi è la boundary (elimino create patch dict)
	BCtype=$( xmllint  --xpath "string(//INPUTDATA/MESH/$BCname/type)" CFD_input.xml )

	if [ "$refMax" = "" ]; then
		refMin=0
		refMax=0
	elif [ "$refMin" = "" ]; then
		refMin=0
	fi

   	echo "   RefMaxMin: $BCname - $refMax $refMin typePath: $BCtype"

	replace_string="$replace_string\t\t$BCname\n\t\t{\n\t\t\tlevel\t( $refMin $refMax);\n\t\t\tpatchInfo\n\t\t\t{\n\t\t\t\ttype  $BCtype;\n\t\t\t}\n\t\t}\n"
done

sed -i "s/SCRIPT-REFINEMENT/$replace_string/g" system/snappyHexMeshDict

#-------------------------------------

replace_string=""

for file in $vol_files
do
  VOLname=${file%.stl}
  
	#se c'è refinementmin refinementmax, altrimenti refinementmax refinementmax , altrimenti 0 0
	refMax=$( xmllint  --xpath "string(//INPUTDATA/MESH/$VOLname/refMax)" CFD_input.xml )
	refMin=$( xmllint  --xpath "string(//INPUTDATA/MESH/$VOLname/refMin)" CFD_input.xml )

	if [ "$refMax" = "" ]; then
		refMin=0
		refMax=0
	elif [ "$refMin" = "" ]; then
		refMin=0
	fi

   	echo "   VolRef: $VOLname - $refMax $refMin"

	replace_string="$replace_string\t\t$VOLname\n\t\t{\n\t\t\tlevel\t( $refMin $refMax);\n\t\t\tfaceZone\t$VOLname;\n\t\t\tcellZone\t$VOLname;\n\t\t\tcellZoneInside\tinside;\n\t\t\tfaceType\tinternal;\n\t\t}\n"
done

sed -i "s/SCRIPT-VOLREF/$replace_string/g" system/snappyHexMeshDict

#-------------------------------------

replace_string=""

for file in $int_files
do
  INTname=${file%.stl}
  
	#se c'è refinementmin refinementmax, altrimenti refinementmax refinementmax , altrimenti 0 0
	refMax=$( xmllint  --xpath "string(//INPUTDATA/MESH/$INTname/refMax)" CFD_input.xml )
	refMin=$( xmllint  --xpath "string(//INPUTDATA/MESH/$INTname/refMin)" CFD_input.xml )

	if [ "$refMax" = "" ]; then
		refMin=0
		refMax=0
	elif [ "$refMin" = "" ]; then
		refMin=0
	fi

   	echo "   INTRef: $INTname - $refMax $refMin"

	replace_string="$replace_string\t\t$INTname\n\t\t{\n\t\t\tlevel\t( $refMin $refMax);\n\t\t\tfaceZone\t$INTname;\n\t\t\tfaceType\tinternal;\n\t\t}\n"
done

sed -i "s/SCRIPT-INTREF/$replace_string/g" system/snappyHexMeshDict

#-------------------------------------

replace_string=""

for file in $baf_files
do
  BAFname=${file%.stl}

        #Verifica esistenza file STL nel file XML
        if [ $(xmllint  --xpath "count(//INPUTDATA/MESH/$BAFname)" CFD_input.xml) -eq 0 ]
        then
           echo " @@@@@@@   MISSING BAFFLE DEFINITION in XML file - $BAFname"
        fi
  
	#se c'è refinementmin refinementmax, altrimenti refinementmax refinementmax , altrimenti 0 0
	refMax=$( xmllint  --xpath "string(//INPUTDATA/MESH/$BAFname/refMax)" CFD_input.xml )
	refMin=$( xmllint  --xpath "string(//INPUTDATA/MESH/$BAFname/refMin)" CFD_input.xml )

	if [ "$refMax" = "" ]; then
		refMin=0
		refMax=0
	elif [ "$refMin" = "" ]; then
		refMin=0
	fi
	
   	echo "   BAFRef: $BAFname - $refMax $refMin"

	replace_string="$replace_string\t\t$BAFname\n\t\t{\n\t\t\tlevel\t( $refMin $refMax);\n\t\t\tfaceZone\t$BAFname;\n\t\t\tfaceType\tbaffle;\n\t\t\tcellZoneInside\tinside;\n\t\t}\n"	
done

sed -i "s/SCRIPT-BAFREF/$replace_string/g" system/snappyHexMeshDict

############################################

echo ""
echo "Geometry ..."

replace_string=""

for file in $surf_files
do
  BCname=${file%.stl}

  replace_string="$replace_string\t$file\n\t{\n\t\ttype\ttriSurfaceMesh;\n\t\tfile\t\"$file\";\n\t\tname\t$BCname;\n\t\tappendRegionName\tfalse;\n\t}\n"
done

sed -i "s/SCRIPT-GEOMETRY/$replace_string/g" system/snappyHexMeshDict

#---------------------------------------
replace_string=""

for file in $int_files
do
  INTname=${file%.stl}

  replace_string="$replace_string\t$INTname\n\t{\n\t\ttype\ttriSurfaceMesh;\n\t\tfile\t\"$file\";\n\t\tappendRegionName\tfalse;\n\t}\n"
done

sed -i "s/SCRIPT-INTGEO/$replace_string/g" system/snappyHexMeshDict

#---------------------------------------

replace_string=""

for file in $vol_files
do
  VOLname=${file%.stl}

  replace_string="$replace_string\t$VOLname\n\t{\n\t\ttype\ttriSurfaceMesh;\n\t\tfile\t\"$file\";\n\t\tappendRegionName\tfalse;\n\t}\n"
done

sed -i "s/SCRIPT-VOLGEO/$replace_string/g" system/snappyHexMeshDict

#---------------------------------------

replace_string=""

for file in $baf_files
do
  BAFname=${file%.stl}

  replace_string="$replace_string\t$BAFname\n\t{\n\t\ttype\ttriSurfaceMesh;\n\t\tfile\t\"$file\";\n\t\tappendRegionName\tfalse;\n\t}\n"
done

sed -i "s/SCRIPT-BAFGEO/$replace_string/g" system/snappyHexMeshDict

############################################

echo ""
echo "Feature extract ..."

replace_string=""

for file in $surf_files
do
  BCname=${file%.stl}

  replace_string="$replace_string \"$file\""
done

replace_string="surfaces ($replace_string);"

sed -i "s/SCRIPT-FEATURE/$replace_string/g" system/surfaceFeaturesDict

############################################

echo ""
echo "Feature extract OpenFOAM.COM ..."

replace_string=""

for file in $surf_files
do
  BCname=${file%.stl}

  replace_string="$replace_string\n\n$file\n{\n\textractionMethod    extractFromSurface;\n\tincludedAngle       150;\n\tsubsetFeatures\n\t{\n\t\tnonManifoldEdges       no;\n\t\topenEdges       yes;\n\t}\n\twriteObj            yes;\n}"
done

sed -i "s/SCRIPT-FEATURE/$replace_string/g" system/surfaceFeatureExtractDict

############################################
# GESTIONE PER CFMESH
############################################

echo ""
echo "Setting meshDict [cfMesh] ..."

## Esportare file FluidDomain.fms
##triSurf().writeFms('FluidDomain.fms')

. /opt/openfoam9/etc/bashrc
. $WM_PROJECT_DIR/bin/tools/RunFunctions
runApplication -a surfaceFeatureEdges constant/cfMeshSurface/FluidDomain.fms constant/cfMeshSurface/FluidDomain-features.fms -angle 45

replace_string="maxCellSize\t$coarseMesh;\nboundaryCellSizeRefinementThickness\t$coarseMesh;"

sed -i "s/SCRIPT-GENERAL/$replace_string/g" system/meshDict

# Refinement ########################### 
replace_string=""

for file in $surf_files
do
  BCname=${file%.stl}

  refMax=$( xmllint  --xpath "string(//INPUTDATA/MESH/$BCname/refMax)" CFD_input.xml )

  echo "   BC ref - $BCname - $refMax"

  replace_string="$replace_string\t\"$BCname.*\"\n\t{\n\t\tadditionalRefinementLevels\t$refMax;\n\t\trefinementThickness\t$coarseMesh;\n\t}\n"
done

sed -i "s/SCRIPT-REFINEMENT/$replace_string/g" system/meshDict

# KEEP REMOVE cells #################### 
replace_string=""

for file in $surf_files
do
  BCname=${file%.stl}

  replace_string="$replace_string\t\"$BCname.*\"\n\t{\n\t\tkeepCells\t1;\n\t}\n"
done

sed -i "s/SCRIPT-KEEPCELLS/$replace_string/g" system/meshDict

# BOUNDARY LAYER cells ################# 
replace_string=""

for file in $surf_files
do
   BCname=${file%.stl}

   #numero di layers per ogni surf (se lo trova gli assegna il valore trovato, altrimenti mette 0)
   numOfLayers=$( xmllint  --xpath "string(//INPUTDATA/MESH/$BCname/numOfLayers)" CFD_input.xml )
   refMax=$( xmllint  --xpath "string(//INPUTDATA/MESH/$BCname/refMax)" CFD_input.xml )

   if [ "$numOfLayers" = "" -o "$numOfLayers" = "0" ]; then
      continue
   fi   

   firstLayer=$( echo "$coarseMesh / 2^$refMax * 0.2 / $numOfLayers " | bc -l | awk '{printf "%10.15f", $0}' )

   echo "   Layers: $BCname - $numOfLayers - $firstLayer"

   replace_string="$replace_string\t\"$BCname.*\"\n\t{\n\t\tnLayers\t$numOfLayers;\n\t\tthickessRatio\t1.2;\n\t\tmaxFirstLayerThickness\t$firstLayer;\n\t\tallowDisontinuity\t0;\n\t}\n"
done

sed -i "s/SCRIPT-BL/$replace_string/g" system/meshDict
